from django.db import models
from django.contrib.auth.models import User
from django.db.models.signals import post_save
from django.dispatch import receiver
from rest_framework.authtoken.models import Token
from items import Items
import random
import uuid


class Rect:
    ''' 
    Rects are created in order to manage regions that
    represent rooms. They are also for checking to see if rooms
    intersect when being generated and placed on the map
    '''

    def __init__(self, coords, size):
        '''
        coords is a tuple containing the top left x, y coordinates
        of the rect. size is a tuple containing the height and width
        of the rect.
        '''
        self.x1, self.y1 = coords
        self.w, self.h = size
        self.x2 = self.x1 + self.w
        self.y2 = self.y1 + self.h

    def __str__(self):
        return f"Rect of width {self.w} and height {self.h} at coordinates {self.x}, {self.y}"

    @property
    def center(self):
        ''' 
        The coordinates of the center of the rectangle in order
        to create tunneling targets for connecting rects together.
        '''
        center_x = int((self.x1 + self.x2) / 2)
        center_y = int((self.y1 + self.y2) / 2)

        return (center_x, center_y)

    def intersects(self, target):
        '''
        Takes in a seperate Rect object and returns true if the rects
        intersect on both the x and y plane.
        '''
        intersect = self.x1 <= target.x2 and self.x2 >= target.x1 and self.y1 <= target.y2 and self.y2 <= target.y1

        return intersect


class Area(models.Model):
    """
    ===Overview===
    The Area model stores data about a collection of Room models
    that relate to each other.


    ===Instance Variables===
    width: This is the width, in rooms, of the area.

    height: This is the height, in rooms, of the area.

    level: The dungeon depth of the Area. This is used to determine
    the relative strength of enemies and loot items.

    max_regions: This is the maximum number of regions that the area
    generator will attempt to create and link together.

    max_region_size: This is the maximum width and height, in rooms,
    that any particular region can be.

    min_region_size: This is the minimum width, and height, in rooms,
    that any particular region can be.
    """
    width = models.IntegerField(default=0)
    height = models.IntegerField(default=0)
    level = models.IntegerField(default=0)
    max_regions = models.IntegerField(default=30)
    max_region_size = models.IntegerField(default=7)
    min_region_size = models.IntegerField(default=3)

    def initialize(self):
        self.grid = []

    def generate_regions(self, area):
        '''
        Generates a maximum number of regions equal to the defined value
        in the Area model. Regions are generated by creating a rect and
        attempting to place it on the map grid. If the rect does not
        intersect with any existing region, it then draws a new region
        on the map and creates a tunnel between it and the last drawn
        region.
        '''

        '''
        Create a 2d array and populate each element with a Room object that
        has a wall sector_type.
        '''
        for x in range(0, width):
            grid.append([])
            for y in range(0, height):
                grid[x].append([])

        '''
        Store the rect of each created region in a list so that we can see
        if future rects intersect and should not be placed.
        '''
        region_list = []

        '''
        Remember the center of the last region placed so we have a target
        to draw a tunnel toward when placing the next region.
        '''
        center_of_last_region = None

        '''
        We loop a number of times equal to the maximum allowed regions on the
        map. This does not ensure that many regions will be created.
        '''

        for i in range(self.max_regions):

            '''
            Randomize a width, height and x,y coordinates for a new region
            '''
            w = random.randint(min_region_size, max_region_size)
            h = random.randint(min_region_size, max_region_size)
            x = random.randint(2, width-(w+2))
            y = random.randint(2, height-(h+2))

            region = Rect((x, y), (w, h))

            '''
            Track if we were able to place the newly created region.
            '''
            placement_failed = False

            '''
            Iterate over previously created regions and see if the
            new region intersects those. If it does, placement has
            failed and we start over generating a new region.
            '''
            for placed_region in region_list:
                if region.intersects(placed_region):
                    placement_failed = True
                    break

            '''
            If placement succeeds we append our region to the list of
            placed regions, draw it onto our map. If we have stored
            the center of a previously placed region, we will draw a 
            tunnel between the new and last one. We then set last center
            to that of the newly placed region.
            '''
            if not placement_failed:
                region_list.append(region)
                draw_region(region, area)
                if center_of_last_region is not None:
                    draw_tunnel(region.center, center_of_last_region, area)

                center_of_last_region = region.center

    def draw_region(self, region, area):
        '''
        region is a rect instance. We iterate over all coordinates within the
        bounds of the rect and populate those coordinates with new instances
        of Room that have floor sector type.
        '''
        for x in range(region.x1, region.x2):
            for y in range(region.y1, region.y2):
                room = Room(x=x, y=y, area=area)
                room.save()

    def draw_tunnel(self, a, b, area):
        '''
        a and b are the centermost points of two seperate regions that have
        been drawn on the map grid. We dig out a tunnel, by making a room
        with the sector type of floor between the x and then the y coords
        of each region.
        '''
        x1, y1 = a
        x2, y2 = b

        for x in range(min(x1, x2), max(x1, x2) + 1):
            room = Room(x=x, y=y1, area=area)
            room.save()

        for y in range(min(y1, y2), max(y1, y2) + 1):
            room = Room(x=x1, y=y, area=area)
            room.save()


class Room(models.Model):
    area = models.ForeignKey(Area, on_delete=models.CASCADE)
    passable = models.BooleanField(default=False)
    x = models.IntegerField(default=0)
    y = models.IntegerField(default=0)
    start_room = models.BooleanField(default=False)
    exit_room = models.BooleanField(default=False)

    def playerNames(self, currentPlayerID):
        return [p.user.username for p in Player.objects.filter(currentRoom=self.id) if p.id != int(currentPlayerID)]

    def playerUUIDs(self, currentPlayerID):
        return [p.uuid for p in Player.objects.filter(currentRoom=self.id) if p.id != int(currentPlayerID)]


class Player(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    currentArea = models.IntegerField(default=0)
    uuid = models.UUIDField(default=uuid.uuid4, unique=True)
    #TODO: add inventory[] to player model
    #TODO: add inventory_limit to player model

    def initialize(self):
        if self.currentRoom == 0:
            self.currentRoom = Room.objects.first().id
            self.save()

    def room(self):
        try:
            return Room.objects.get(id=self.currentRoom)
        except Room.DoesNotExist:
            self.initialize()
            return self.room()
    
    #TODO: Update room object to initialize with item and pyt this func somewhere that makes sense
    def add_item_to_room(self, item):  # Add capability to add items to room
        '''
        This will add random items to the rooms. 
        '''
        item.append(item)
        
        #This will throw an output to the player with the item they stumbled onto in their current room
        if player.currentRoom != 0:
        for i in player.currentRoom.items:
            print(
                "><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><"

                f"\n\n *** You stumbled onto an item *** \n     {i.name}\n\n"

                "><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><")
    
    #TODO: Finish funcs. for player inventory and move this func to better location
    def get_inventory(self):
    '''
    Get's the players current inventory. Right now, Weapons are the only items players can add to their loot
    '''

        if len(self.inventory) > 0: # Check the length of the inventory list
            for i in self.inventory: # Iterate over the list
                print(
                    f"\nYou are carrying: \n*{i.name}") # Print the items in the list
        else:
            print("You have nothing in your inventory.")

    # Add item to inventory if space is available
    # If inv is full print warning msg, else print conf msg, 
    def add_to_inv(self, item):
        '''
        This adds the item to the players inventory. Inventory has a maximum capacity of 10 items. If the player
        does not have <10 items in inventory, they will not be able to add the item until they drop an existing
        item from inventory
        '''
        if len(self.inventory) >= self.inventory_limit:
            print(f"\n\033[31m'WARNING: \033[39m'Unable to add {item} to inventory. \nYour inventory is full. Drop and item to free up space.")
        elif item not in self.inventory and item in self.currentRoom.items:
            self.inventory.append(item)
            for i in self.inventory:
                print(f"\n\n\n\033[32m'SUCCESS! \033[39m'ITEM: {i.name}\nACCURACY: {i.style_description}\nDAMAGE: {i.finish_description}\nFYI: Check your inventory at any time[i] then[Enter]<<<")
        
    # Remove item at given position
    def remove_fr_inv(self, item):  # Add ability to drop item from player inventory
        '''
        This removes the item from the players inventory. 
        '''

        if item in self.inventory:
            self.inventory.remove(item)
            for i in self.inventory:
                print(f"\n You dropped the {i.name}")
                self.get_inventory()

        else:
            print(f"\n You don't have {i.name} in your inventory")


@receiver(post_save, sender=User)
def create_user_player(sender, instance, created, **kwargs):
    if created:
        Player.objects.create(user=instance)
        Token.objects.create(user=instance)


@receiver(post_save, sender=User)
def save_user_player(sender, instance, **kwargs):
    instance.player.save()
